package com.tamj0rd2.ktcheck

import com.tamj0rd2.ktcheck.core.Seed
import com.tamj0rd2.ktcheck.v1.CombinerContext
import com.tamj0rd2.ktcheck.v1.GenV1
import com.tamj0rd2.ktcheck.v1.OneOfEmpty
import java.util.*
import kotlin.random.Random
import kotlin.reflect.KClass

interface Gen<T> {
    companion object : GenFacade by GenV1
}

interface GenFacade {
    /**
     * Samples a value from the generator using the provided seed.
     *
     * @param seed The seed to use for sampling.
     * @return A sampled value of type T.
     */
    fun <T> Gen<T>.sample(seed: Long = Random.nextLong()): T

    /**
     * Produces an infinite sequence of samples from the generator using the provided seed.
     *
     * @param random The random instance used to create seeds for sampling. Defaults to [Random.Default].
     * @return A sequence of sampled values of type T.
     */
    fun <T> Gen<T>.samples(seed: Long = Random.nextLong()): Sequence<T> =
        Seed.sequence(Seed(seed)).map { sample(it.value) }

    /**
     * Produces a new generator by applying the provided function to the value generated by this generator.
     *
     * The shrinks from this generator are preserved in the resulting generator.
     *
     * Use this when you want to transform the values produced by a generator without changing its structure or shrinks.
     *
     * @param fn A function that takes a value of type T and returns a value of type R.
     * @return A new generator that produces values of type R.
     */
    fun <T, R> Gen<T>.map(fn: (T) -> R): Gen<R>

    /**
     * Produces a new generator by applying the provided function to the value generated by this generator.
     * The resulting generator is then used to generate the final value.
     *
     * The shrinks from both generators are combined to provide a comprehensive set of shrinks for the final value.
     *
     * Use this when you want to create a generator that depends on the value produced by another generator.
     * If you instead want to combine two independent generators, consider using [plus] or [combineWith].
     *
     * @param fn A function that takes a value of type T and returns a generator of type R.
     * @return A new generator that produces values of type R.
     */
    fun <T, R> Gen<T>.flatMap(fn: (T) -> Gen<R>): Gen<R>

    /**
     * Combines two independent generators using the provided combining function.
     *
     * The shrinks from both generators are combined to provide a comprehensive set of shrinks for the final value.
     *
     * Use this when you want to create a new generator that produces values based on two independent generators. i.e
     * the value from one generator does not influence the value from the other generator.
     *
     * @param nextGen The second generator to combine with this generator.
     * @param combine A function that takes values from both generators and combines them into a value of type R.
     * @return A new generator that produces values of type R.
     */
    fun <T1, T2, R> Gen<T1>.combineWith(nextGen: Gen<T2>, combine: (T1, T2) -> R): Gen<R>

    /**
     * Combines multiple generators into a single generator using a builder-style DSL.
     * Each generator in the block is bound sequentially, and their shrinks are combined.
     *
     * Example:
     * ```
     * val gen = Gen.combine {
     *     val x = Gen.int().bind()
     *     val y = Gen.int().bind()
     *     x to y
     * }
     * ```
     *
     * This is equivalent to using [plus] but with a more convenient syntax:
     * ```
     * val gen = (Gen.int() + Gen.bool()).map { (x, y) -> x + y }
     * ```
     *
     * **Warning about conditionals:** The combiner requires that bind functions will be called in the same order each time.
     * Conditionals that affect whether trailing [CombinerContext.bind] calls are called will shrink correctly.
     * However, conditionals that skip non-trailing [CombinerContext.bind] calls will cause invalid shrinks.
     */
    fun <T> combine(block: CombinerContext.() -> T): Gen<T>

    /**
     * Filters generated values using the given [predicate]. Although this generator supports shrinking, it is very
     * inefficient. Instead of using this generator, consider using generators that do not throw exceptions.
     */
    fun <T> Gen<T>.filter(predicate: (T) -> Boolean) = filter(100, predicate)

    /**
     * Filters generated values using the given [predicate]. Although this generator supports shrinking, it is very
     * inefficient. Instead of using this generator, consider using generators that do not throw exceptions.
     */
    fun <T> Gen<T>.filter(threshold: Int, predicate: (T) -> Boolean): Gen<T>

    /**
     * Ignores exceptions of type [klass] thrown during generation. Although this generator supports shrinking, it is very
     * inefficient. Instead of using this generator, consider using generators that do not throw exceptions.
     */
    fun <T> Gen<T>.ignoreExceptions(klass: KClass<out Exception>, threshold: Int = 100): Gen<T>

    fun <T> constant(value: T): Gen<T>
    fun bool(): Gen<Boolean>
    fun int(range: IntRange = Int.MIN_VALUE..Int.MAX_VALUE): Gen<Int>
    fun long(): Gen<Long>

    fun uuid(): Gen<UUID> = (long() + long()).map { UUID(it.first, it.second) }

    fun char(chars: Iterable<Char>): Gen<Char> =
        oneOf(chars.distinct().sorted())

    fun Gen<Char>.string(size: IntRange): Gen<String> = list(size).map { it.joinToString("") }
    fun Gen<Char>.string(size: Int) = string(size..size)

    // todo: at this point, some kind of builder would help with optional parameters
    fun <T> Gen<T>.list(size: IntRange = 0..100, distinct: Boolean = false): Gen<List<T>>

    fun <T> Gen<T>.list(size: Int, distinct: Boolean = false): Gen<List<T>> = list(size..size, distinct)

    fun <T> Gen<T>.set(size: IntRange = 0..100): Gen<Set<T>> = list(size = size, distinct = true).map { it.toSet() }

    fun <T> Gen<T>.set(size: Int): Gen<Set<T>> = set(size..size)

    /** Shrinks towards the first generator */
    fun <T> oneOf(vararg gens: Gen<T>): Gen<T> = oneOf(gens.toList())

    /** Shrinks toward the first generator */
    fun <T> oneOf(gens: Collection<Gen<T>>): Gen<T>

    /** Shrinks toward the first value. Individual values will not be shrunk. */
    fun <T> oneOf(values: Iterable<T>): Gen<T> {
        val options = values.toList()
        if (options.isEmpty()) throw OneOfEmpty()
        return int(0..<options.size).map { options[it] }
    }

    /**
     * Combines two independent generators into a single generator that produces a tuple of both values.
     * Shrinking is performed independently on each component.
     *
     * Example:
     * ```
     * // Gen<Pair<Int, Boolean>>
     * val gen2 = Gen.int() + Gen.boolean()
     * ```
     *
     * To combine more than 2 generators, use [combine] instead.
     *
     * For dependent generation (where the second generator depends on the first value),
     * use [flatMap] or [combine] instead.
     */
    infix operator fun <T1, T2> Gen<T1>.plus(nextGen: Gen<T2>) = combineWith(nextGen, ::Pair)
}
