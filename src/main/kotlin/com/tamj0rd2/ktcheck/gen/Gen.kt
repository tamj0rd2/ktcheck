package com.tamj0rd2.ktcheck.gen

import com.tamj0rd2.ktcheck.producer.ProducerTree
import com.tamj0rd2.ktcheck.producer.deriveSeed
import kotlin.random.Random

/**
 * A generator that can produce values of type T.
 *
 * Generators can be transformed and combined using various methods such as [map], [flatMap], and [combineWith].
 *
 * @param T The type of values produced by this generator.
 */
sealed class Gen<T> {
    internal abstract fun generate(tree: ProducerTree): GenResult<T>

    /**
     * Produces a new generator by applying the provided function to the value generated by this generator.
     *
     * The shrinks from this generator are preserved in the resulting generator.
     *
     * Use this when you want to transform the values produced by a generator without changing its structure or shrinks.
     *
     * @param fn A function that takes a value of type T and returns a value of type R.
     * @return A new generator that produces values of type R.
     */
    fun <R> map(fn: (T) -> R): Gen<R> = CombinatorGenerator { tree ->
        val (value, shrinks) = generate(tree)
        GenResult(fn(value), shrinks)
    }

    /**
     * Produces a new generator by applying the provided function to the value generated by this generator.
     * The resulting generator is then used to generate the final value.
     *
     * The shrinks from both generators are combined to provide a comprehensive set of shrinks for the final value.
     *
     * Use this when you want to create a generator that depends on the value produced by another generator.
     * If you instead want to combine two independent generators, consider using [plus] or [combineWith].
     *
     * @param fn A function that takes a value of type T and returns a generator of type R.
     * @return A new generator that produces values of type R.
     */
    fun <R> flatMap(fn: (T) -> Gen<R>): Gen<R> = CombinatorGenerator { tree ->
        val (leftValue, leftShrinks) = generate(tree.left)
        val (rightValue, rightShrinks) = fn(leftValue).generate(tree.right)
        GenResult(
            value = rightValue,
            shrinks = tree.combineShrinks(leftShrinks, rightShrinks)
        )
    }

    /**
     * Combines two independent generators using the provided combining function.
     *
     * The shrinks from both generators are combined to provide a comprehensive set of shrinks for the final value.
     *
     * Use this when you want to create a new generator that produces values based on two independent generators. i.e
     * the value from one generator does not influence the value from the other generator.
     *
     * @param nextGen The second generator to combine with this generator.
     * @param combine A function that takes values from both generators and combines them into a value of type R.
     * @return A new generator that produces values of type R.
     */
    fun <T2, R> combineWith(nextGen: Gen<T2>, combine: (T, T2) -> R): Gen<R> = CombinatorGenerator { tree ->
        val (thisValue, thisShrinks) = generate(tree.left)
        val (nextValue, nextShrinks) = nextGen.generate(tree.right)
        GenResult(
            value = combine(thisValue, nextValue),
            shrinks = tree.combineShrinks(thisShrinks, nextShrinks)
        )
    }

    companion object {
        /**
         * Produces an infinite sequence of samples from the generator using the provided seed.
         *
         * @param random The random instance used to create seeds for sampling. Defaults to [Random.Default].
         * @return A sequence of sampled values of type T.
         */
        fun <T> Gen<T>.samples(seed: Long = Random.nextLong()) =
            generateSequence(seed) { prev -> deriveSeed(prev, 0) }.map { sample(it) }

        /**
         * Samples a value from the generator using the provided seed.
         *
         * @param seed The seed to use for sampling.
         * @return A sampled value of type T.
         */
        fun <T> Gen<T>.sample(seed: Long = Random.nextLong()): T = generate(ProducerTree.fromSeed(seed)).value
    }
}

/**
 * The result of generating a value from a generator, including the generated value and its shrinks.
 * Shrinks are represented as a sequence of [ProducerTree]s, allowing for lazy evaluation and efficient traversal.
 */
internal data class GenResult<T>(val value: T, val shrinks: Sequence<ProducerTree>)

private class CombinatorGenerator<T>(private val generator: (ProducerTree) -> GenResult<T>) : Gen<T>() {
    override fun generate(tree: ProducerTree): GenResult<T> = generator(tree)
}
