package com.tamj0rd2.ktcheck.gen

import com.tamj0rd2.ktcheck.producer.ProducerTree
import com.tamj0rd2.ktcheck.producer.Seed
import kotlin.random.Random

internal data class GenContext(
    val tree: ProducerTree,
    val mode: GenMode,
)

internal enum class GenMode {
    Initial,
    Shrinking,
}

/**
 * A generator that can produce values of type T.
 *
 * Generators can be transformed and combined using various methods such as [map], [flatMap], and [combineWith].
 *
 * @param T The type of values produced by this generator.
 */
sealed class Gen<T> {
    internal abstract fun GenContext.generate(): GenResult<T>

    internal fun generate(tree: ProducerTree, mode: GenMode): GenResult<T> =
        GenContext(tree, mode).generate()

    /**
     * Produces a new generator by applying the provided function to the value generated by this generator.
     *
     * The shrinks from this generator are preserved in the resulting generator.
     *
     * Use this when you want to transform the values produced by a generator without changing its structure or shrinks.
     *
     * @param fn A function that takes a value of type T and returns a value of type R.
     * @return A new generator that produces values of type R.
     */
    fun <R> map(fn: (T) -> R): Gen<R> = CombinatorGenerator {
        val (value, shrinks) = generate(tree, mode)
        GenResult(fn(value), shrinks)
    }

    /**
     * Produces a new generator by applying the provided function to the value generated by this generator.
     * The resulting generator is then used to generate the final value.
     *
     * The shrinks from both generators are combined to provide a comprehensive set of shrinks for the final value.
     *
     * Use this when you want to create a generator that depends on the value produced by another generator.
     * If you instead want to combine two independent generators, consider using [plus] or [combineWith].
     *
     * @param fn A function that takes a value of type T and returns a generator of type R.
     * @return A new generator that produces values of type R.
     */
    fun <R> flatMap(fn: (T) -> Gen<R>): Gen<R> = CombinatorGenerator {
        val (leftValue, leftShrinks) = generate(tree.left, mode)
        val (rightValue, rightShrinks) = fn(leftValue).generate(tree.right, mode)
        GenResult(
            value = rightValue,
            shrinks = tree.combineShrinks(leftShrinks, rightShrinks)
        )
    }

    /**
     * Combines two independent generators using the provided combining function.
     *
     * The shrinks from both generators are combined to provide a comprehensive set of shrinks for the final value.
     *
     * Use this when you want to create a new generator that produces values based on two independent generators. i.e
     * the value from one generator does not influence the value from the other generator.
     *
     * @param nextGen The second generator to combine with this generator.
     * @param combine A function that takes values from both generators and combines them into a value of type R.
     * @return A new generator that produces values of type R.
     */
    fun <T2, R> combineWith(nextGen: Gen<T2>, combine: (T, T2) -> R): Gen<R> =
        CombinatorGenerator {
            val (thisValue, thisShrinks) = generate(tree.left, mode)
            val (nextValue, nextShrinks) = nextGen.generate(tree.right, mode)
            GenResult(
                value = combine(thisValue, nextValue),
                shrinks = tree.combineShrinks(thisShrinks, nextShrinks)
            )
        }

    companion object {
        /**
         * Produces an infinite sequence of samples from the generator using the provided seed.
         *
         * @param random The random instance used to create seeds for sampling. Defaults to [Random.Default].
         * @return A sequence of sampled values of type T.
         */
        fun <T> Gen<T>.samples(seed: Long = Random.nextLong()) =
            generateSequence(Seed(seed)) { it.next(0) }.map { sample(it.value) }

        /**
         * Samples a value from the generator using the provided seed.
         *
         * @param seed The seed to use for sampling.
         * @return A sampled value of type T.
         */
        fun <T> Gen<T>.sample(seed: Long = Random.nextLong()): T = generate(
            tree = ProducerTree.new(Seed(seed)),
            mode = GenMode.Initial
        ).value
    }
}

/**
 * The result of generating a value from a generator, including the generated value and its shrinks.
 * Shrinks are represented as a sequence of [ProducerTree]s, allowing for lazy evaluation and efficient traversal.
 */
internal data class GenResult<T>(val value: T, val shrinks: Sequence<ProducerTree>)

private class CombinatorGenerator<T>(private val generator: GenContext.() -> GenResult<T>) : Gen<T>() {
    override fun GenContext.generate(): GenResult<T> = generator()
}

sealed class GenerationException(message: String, cause: Throwable? = null) : IllegalStateException(message, cause)
