package com.tamj0rd2.ktcheck

import com.tamj0rd2.ktcheck.v1.CombinerContext
import com.tamj0rd2.ktcheck.v1.GenV1
import com.tamj0rd2.ktcheck.v1.OneOfEmpty
import java.util.*
import kotlin.reflect.KClass

interface GenBuilders {
    /**
     * Produces a new generator by applying the provided function to the value generated by this generator.
     *
     * The shrinks from this generator are preserved in the resulting generator.
     *
     * Use this when you want to transform the values produced by a generator without changing its structure or shrinks.
     *
     * @param fn A function that takes a value of type T and returns a value of type R.
     * @return A new generator that produces values of type R.
     */
    fun <T, R> GenV1<T>.map(fn: (T) -> R): GenV1<R>

    /**
     * Produces a new generator by applying the provided function to the value generated by this generator.
     * The resulting generator is then used to generate the final value.
     *
     * The shrinks from both generators are combined to provide a comprehensive set of shrinks for the final value.
     *
     * Use this when you want to create a generator that depends on the value produced by another generator.
     * If you instead want to combine two independent generators, consider using [plus] or [combineWith].
     *
     * @param fn A function that takes a value of type T and returns a generator of type R.
     * @return A new generator that produces values of type R.
     */
    fun <T, R> GenV1<T>.flatMap(fn: (T) -> GenV1<R>): GenV1<R>

    /**
     * Combines two independent generators using the provided combining function.
     *
     * The shrinks from both generators are combined to provide a comprehensive set of shrinks for the final value.
     *
     * Use this when you want to create a new generator that produces values based on two independent generators. i.e
     * the value from one generator does not influence the value from the other generator.
     *
     * @param nextGen The second generator to combine with this generator.
     * @param combine A function that takes values from both generators and combines them into a value of type R.
     * @return A new generator that produces values of type R.
     */
    fun <T1, T2, R> GenV1<T1>.combineWith(nextGen: GenV1<T2>, combine: (T1, T2) -> R): GenV1<R>

    /**
     * Combines multiple generators into a single generator using a builder-style DSL.
     * Each generator in the block is bound sequentially, and their shrinks are combined.
     *
     * Example:
     * ```
     * val gen = Gen.combine {
     *     val x = Gen.int().bind()
     *     val y = Gen.int().bind()
     *     x to y
     * }
     * ```
     *
     * This is equivalent to using [plus] but with a more convenient syntax:
     * ```
     * val gen = (Gen.int() + Gen.bool()).map { (x, y) -> x + y }
     * ```
     *
     * **Warning about conditionals:** The combiner requires that bind functions will be called in the same order each time.
     * Conditionals that affect whether trailing [CombinerContext.bind] calls are called will shrink correctly.
     * However, conditionals that skip non-trailing [CombinerContext.bind] calls will cause invalid shrinks.
     */
    fun <T> combine(block: CombinerContext.() -> T): GenV1<T>

    /**
     * Filters generated values using the given [predicate]. Although this generator supports shrinking, it is very
     * inefficient. Instead of using this generator, consider using generators that do not throw exceptions.
     */
    fun <T> GenV1<T>.filter(predicate: (T) -> Boolean) = filter(100, predicate)

    /**
     * Filters generated values using the given [predicate]. Although this generator supports shrinking, it is very
     * inefficient. Instead of using this generator, consider using generators that do not throw exceptions.
     */
    fun <T> GenV1<T>.filter(threshold: Int, predicate: (T) -> Boolean): GenV1<T>

    /**
     * Ignores exceptions of type [klass] thrown during generation. Although this generator supports shrinking, it is very
     * inefficient. Instead of using this generator, consider using generators that do not throw exceptions.
     */
    fun <T> GenV1<T>.ignoreExceptions(klass: KClass<out Exception>, threshold: Int = 100): GenV1<T>

    fun <T> constant(value: T): GenV1<T>
    fun bool(): GenV1<Boolean>
    fun int(range: IntRange = Int.MIN_VALUE..Int.MAX_VALUE): GenV1<Int>
    fun long(): GenV1<Long>

    fun uuid(): GenV1<UUID> = (long() + long()).map { UUID(it.first, it.second) }

    fun char(chars: Iterable<Char>): GenV1<Char> =
        oneOf(chars.distinct().sorted())

    fun GenV1<Char>.string(size: IntRange): GenV1<String> = list(size).map { it.joinToString("") }
    fun GenV1<Char>.string(size: Int) = string(size..size)

    // todo: at this point, some kind of builder would help with optional parameters
    fun <T> GenV1<T>.list(size: IntRange = 0..100, distinct: Boolean = false): GenV1<List<T>>

    fun <T> GenV1<T>.list(size: Int, distinct: Boolean = false): GenV1<List<T>> = list(size..size, distinct)

    fun <T> GenV1<T>.set(size: IntRange = 0..100): GenV1<Set<T>> = list(size = size, distinct = true).map { it.toSet() }

    fun <T> GenV1<T>.set(size: Int): GenV1<Set<T>> = set(size..size)

    /** Shrinks towards the first generator */
    fun <T> oneOf(vararg gens: GenV1<T>): GenV1<T> = oneOf(gens.toList())

    /** Shrinks toward the first generator */
    fun <T> oneOf(gens: Collection<GenV1<T>>): GenV1<T>

    /** Shrinks toward the first value. Individual values will not be shrunk. */
    fun <T> oneOf(values: Iterable<T>): GenV1<T> {
        val options = values.toList()
        if (options.isEmpty()) throw OneOfEmpty()
        return int(0..<options.size).map { options[it] }
    }

    /**
     * Combines two independent generators into a single generator that produces a tuple of both values.
     * Shrinking is performed independently on each component.
     *
     * Example:
     * ```
     * // Gen<Pair<Int, Boolean>>
     * val gen2 = Gen.int() + Gen.boolean()
     * ```
     *
     * To combine more than 2 generators, use [combine] instead.
     *
     * For dependent generation (where the second generator depends on the first value),
     * use [flatMap] or [combine] instead.
     */
    infix operator fun <T1, T2> GenV1<T1>.plus(nextGen: GenV1<T2>) = combineWith(nextGen, ::Pair)
}
